\documentclass{article}
\input{macros}
\usepackage{verbatim}
\usepackage{hyperref}
\begin{document}
\section{Introduction}

The objective of this tool is to translate a given timed contract to a Larva specification. This specification can be used to generate AspectJ code which, once weaved in a Java system, can be used to perform runtime verification on it.

Figure 1 shows a usage flow example of the tool and the output provided by it.

\begin{figure}[hp]
  \centering
  \includegraphics[scale=0.5]{Larva-rt-tutorial.png}
\end{figure}

The role of the tool, highlighted in green, is the translation from a Contract Specification to a Larva Specification. The latter defines a DATE consisting of two states: an initial one, and a bad one, which the system reaches whenever the contract is violated.

The result is, therefore, an AspectJ monitoring code, which can be used to verify in runtime if a contract is respected in a system.

\section{Contract Calculus}

The language in which the contract are specified is based on the one explained in \cite{untimed}. The paper specifies the set of valid formulae, along with its semanics.

A contract defines what actions a certain agent is allowed, obligated, or forbidden to do within a specific amount of time. It can also be a conjuction or disjuction of contract, a sequential contract (the first contract must be enforced, then the second), a reparation contract (if the first contract is violated, the second must be enforced), a recursive contract (the contract must be enforced each given amount of time), a wait contract, or the trivially satisfied and violated ones.

In the implementation, each agent will correspond to a Java class, while actions will correspond to method calls. Time is expressed in milliseconds.

Table 1 shows an equivalence between each of the symbols of the language defined in the paper and the language that the tool will take as input.

\clearpage

\begin{table}[hp]
\centering
\caption{Equivalence table}
\label{my-label}
\begin{tabular}{|l|l|l|}
 Symbol in the paper & Symbol in the implementation & Semantics \\ \hline
 $\top$ & sat & Trivially satisfied                                    \\
 $\bot$ & vio & Trivially violated                                    \\
 wait(d) & wait[d] & Wait \textit{d} milliseconds                                   \\
 rec & rec($\phi$) & Recursion (enforce $\phi$ repeatedly)        \\
 $\wedge$ & \& & Conjuction                                     \\
 $\vee$ & $|$  & Disjuction                                     \\
; & ; & Sequential                                      \\
  $\violationrec$ & $>>$ & Reparation            \\
  $\ff{k}{a}[d]$  & F(a $->$ k){[}d{]} & Prohibition \\
  $\pp{k}{a}[d]$  & P(a $->$ k){[}d{]} & Permission (not implemented) \\
  $\oo{k}{a}[d]$  & O(a $->$ k){[}d{]} & Obligation \\
                                         
\end{tabular}
\end{table}

Note that the paper defines a conditional contract which is not implemented yet. The permission contract is not implemented, neither.

In order to clarify the syntax of the strings that the tool takes as input, we will adapt some contract examples from the paper. Below, we present how four different contracts would be written, first in the notation used in the paper and then in the one that the tool takes as input. \\

\small
\noindent
    $\phi_0 ::= \pp{p}{\ci}[200]$\\
    P(p -$>$ checkin)[200] \\
    \\
    $\phi_1 ::= \oo{p}{\pbp}[500]\violationrec \oo{p}{\gbch}[300]$\\
    O(p -$>$ PBP)[500] $>>$ O(p -$>$ GBCh[300] \\
    \\
    $\phi_2 ::= \oo{p}{\shp}[800]$\\
    O(p -$>$ ShP)[800] \\
    \\
    $\phi_3  ::= 
        (\ff{p}{\weapon}[900]) \wedge (\ff{p}{\liq}[800] \violationrec \oo{p}{\dliq}[800])$\\
            F(p -$>$ weapon)[900] \& (F(p -$>$ liq)[800] $j>>$ O(p -$>$ dliq)[800]) \\
            \\
    $\phi_4 ::= (\pp{p}{\board}[200] ; \pp{p}{\hl}[500]) \violationrec (\oo{c}{\board}[200])$ \\
    (P(p -$>$ board)[200] ; P(p -$>$ hl)[500]) $>>$ O(c -$>$ board)[200]
    \\
\normalsize

Note that the tool does not allow binding a contract to a variable and then using it; only one contact may be defined. Therefore, if we wanted to define the contract $\phi_1 ; \phi_2 ; \phi_3$, we would have to write it as follows:

\small

\begin{verbatim}
(O(p -> PBP)[500] >> O(p -> GBCh)[300]) ; O(p -> ShP)[800] ; 
(F(p -> weapon)[900] & (O(p -> liq)[800] >> F(p -> dliq)[800]))
\end{verbatim}

\normalsize

\section{How to use}
In order to use this tool, it is necessary to have the ANTLR parser generator tool installed. Instructions on how to do it are available in its official GitHub site \footnote{\url{https://github.com/antlr/antlr4/blob/master/doc/getting-started.md}}.

Once ANTLR is properly set up, the \textit{antlr4} and \textit{grun} commands being available, the grammar (inside the \textit{parser} directory) may be compiled as follows:

\begin{verbatim}
javac ParseUtils/*.java
antlr4 ContractsToLarva.g4
javac -cp . *.java
\end{verbatim}

Then, the resulting parser may be used to generate Larva code from a contract specified in \textit{contract.txt}:

\begin{verbatim}
grun ContractsToLarva s -o contract.txt > larva_output.lrv
\end{verbatim}

Now, the code in \textit{$larva\_output.lrv$} may be used to generate the aspects necessary to monitor the desired system. Note that, both when compiling and using the aspects, the package \textit{contractModels} must be available in the Java Classpath. Makefiles automating both the grammar compilation process and the Larva code generation and use can be found in the \textit{parser} directory and the root directory, respectively.

\subsection{Example}
A ready to use example of a system to be monitored is located in the \textit{exampleBoardingSystem} directory. A single agent, \textit{Passenger}, exists, and the actions it performs are located in \textit{Main.java}. For example, if we monitor the following code:

\begin{verbatim}
Thread.sleep(600);
p.GBCh();
Thread.sleep(400);
p.ShP();
Thread.sleep(1000);
p.dliq();
\end{verbatim}

With the Larva code generated by using the tool with the following contract as input:

\begin{verbatim}
(O(p -> PBP)[500] >> O(p -> GBCh)[300]) ; O(p -> ShP)[800] ; 
(F(p -> weapon)[900] & (O(p -> liq)[800] >> F(p -> dliq)[800]))
\end{verbatim}

We obtain the following output:

\begin{verbatim}
Contract violated after agent Passenger performed action dliq after 
100 ms of timeout
[test]MOVED ON METHODCALL: void exampleBoardingSystem.Passenger.dliq() 
TO STATE::> !!!SYSTEM REACHED BAD STATE!!! bad
aspects._asp_exBoarding0.ajc$before$aspects__asp_exBoarding0$6$d5407a35
(_asp_exBoarding0.aj:64)
exampleBoardingSystem.Main.run(Main.java:16)
java.lang.Thread.run(Thread.java:748) 
\end{verbatim}

Which is the expected one.

\end{document}